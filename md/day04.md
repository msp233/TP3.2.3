# 一、ThinkPHP中的模型
 
 ## 1、数据对象创建
 数据对象也就是父类模型中的$this->data，上一天我们在使用AR模式时使用了数据对象，
 在模型实例化的时候数据对象还是一个空数组，在后来使用了魔术方法__set来设置了数据对象的值。  

 ```
 public function __set($name,$value){
    //设置数据对象属性
    $this->data[$name] = $value;
 }
 ```
从上述的一个流程中我们可以得出，既然data属性之前是空数组，后期使用的时候需要先给其赋值，  
也就说明，**在使用数据对象的时候必须先创建数据对象**。而__set 是设置数据对象的一种方法；
但是这种方式在使用时并不方便，原因是设置一个属性就得写一行代码；
因此在ThinkPHP中系统还提供另外一种批量设置数据对象的方法，create方法。(默认取post数据)  
语法：  
 $model->create();
 
 ThinkPHP -> Model.class.php 文件中的create()方法
 ```
  // 如果没有传值默认取POST数据
 if(empty($data)) {
     $data   =   I('post.');
 }elseif(is_object($data)){
     $data   =   get_object_vars($data);
 }
 ```
 通过它的实现代码，可以发现，如果不给create方法传递参数，则其默认使用post中的数据。
 ```
 // 赋值当前数据对象
 $this->data =   $data;
 // 返回创建的数据以供其他调用
 return $data;
 ```
 在结尾的两行代码中，其做了2个操作
 1. 将处理完成的data数据赋值给了data属性，这步就是创建数据对象。
 2. 将处理完成的数据返回出去。
 
 案例：改写之前编写的部门信息入库的代码，使用数据对象的创建方式。
 ```
 //add方法
     public function add(){
         //判断请求类型
         //$_POST
         if(IS_POST){
             $model = M('Dept');
             //数据对象的创建
             $data = $model->create();//不传递参数则接收post数据
             $re = $model->add($data);
             //注意：create()返回值可以不接收，接收一般为了打印出来看数据，
             //add()也可以不传递$data参数,add不传递参数，表示使用数据对象的值
             if($re){
                 $this->success('添加成功',U('showList'),3);
             }else{
                 $this->error('添加失败');
             }
 
         }else{
             //查询出顶级部门
             $model = M('Dept');
             $data = $model->where('pid = 0')->select();
             //展示数据
             $this->assign('data',$data);
             //展示模板
             $this->display();
         }
     }
 ```
- 说明：如果表单中字段和数据表中字段不匹配，则在创建数据对象的时候会被过滤掉
注意：create()返回值可以不接收，接收一般为了打印出来看数据，  
- 关于是否接收数据对象创建方法返回值说明：  
add()也可以不传递数据参数,add不传递参数，表示使用数据对象的值。
- 如果使用自动验证的时候，则必须要接收返回值。

## 2、自动验证

自动验证就是在提交数据时，系统会按照指定的**规则**，进行数据的有效性、合理性的验证。
上述提及到的规则，系统默认没有，如果需要使用自动验证，规则需要我们自己去定义。  

在前端中 javascript的验证叫前端验证，在ThinkPHP中也存在验证机制，这样的验证称之为后端验证。  

自动验证语法：没有语法，由数据对象创建方法create方法实现自动验证，我们需要写的就是验证规则。
```
// 数据自动验证
if(!$this->autoValidation($data,$type)) return false;
```
因为在create方法中执行了自动验证的处理，如果需要使用自动验证，则必须要用数据对象创建方法进行接收数据。  

那如何定义，所谓的规则呢？ 
ThinkPHP -> Model.class.php
```
protected $_validate        =   array();  // 自动验证定义
```
在父类模型中存在一个成员属性，叫做_validate，这个属性是保存验证规则的。由于不能在父类模型中直接更改属性，
**所以可以把这个属性复制到子类（自定义模型）中去定义规则**。  
```
//声明模型并且继承父类模型
class DeptModel extends Model{
    //自动验证定义
    protected $_validate = array();
}
```
规则编写（参考手册）：  
无论是什么方法，验证股则的定义是统一的规则，定义格式为：
```
array( 
    array(验证字段1,验证规则,错误提示,[验证条件,附加规则,验证时间]), 
    array(验证字段2,验证规则,错误提示,[验证条件,附加规则,验证时间]),
    ...... ); 
```
必选参数：  
1. 验证字段：表单中每一个表单项的name值；
2. 验证规则：要进行验证的规则，需要结合附加规则，如果在使用正则验证的附加规则情况下，
系统还内置了一些常用正则验证的规则，可以直接作为验证规则使用，
包括：require 字段必须、email 邮箱、url URL地址、currency 货币、number 数字。 
3. 提示信息：用于验证失败后的提示信息定义 
可选参数：
4. 验证条件 （可选）：
- 0 存在字段就验证（默认）
- 1 必须验证 
- 2 值不为空的时候验证 

5. 附加规则
附加规则：结合验证规则，两种规则配合起来使用，具体支持的方法，可以参考手册“自动验证”
```
规则  说明  
regex  正则验证，定义的验证规则是一个正则表达式（默认）  
function  函数验证，定义的验证规则是一个函数名  
callback  方法验证，定义的验证规则是当前模型类的一个方法  
confirm  验证表单中的两个字段是否相同，定义的验证规则是一个字段名  
equal  验证是否等于某个值，该值由前面的验证规则定义  
notequal  验证是否不等于某个值，该值由前面的验证规则定义（3.1.2版本新增）  
in  验证是否在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串  
notin  验证是否不在某个范围内，定义的验证规则可以是一个数组或者逗号分割的字符串（3.1.2版本新增）  
length  验证长度，定义的验证规则可以是一个数字（表示固定长度）或者数字范围（例如3,12 表示长度从3到12的范围）  
between  验证范围，定义的验证规则表示范围，可以使用字符串或者数组，例如1,31或者array(1,31)  
notbetween  验证不在某个范围，定义的验证规则表示范围，可以使用字符串或者数组（3.1.2版本新增）  
expire  验证是否在有效期，定义的验证规则表示时间范围，可以到时间，例如可以使用 2012-1-15,2013-1-15 表示当前提交有效期在2012-1-15到2013-1-15之间，也可以使用时间戳定义  
ip_allow  验证IP是否允许，定义的验证规则表示允许的IP地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6  
ip_deny  验证IP是否禁止，定义的验证规则表示禁止的ip地址列表，用逗号分隔，例如201.12.2.5,201.12.2.6  
unique  验证是否唯一，系统会根据字段目前的值查询数据库来判断是否存在相同的值，当表单数据中包含主键字段时unique不可用于判断主键字段本身  
```

6. 验证时间（可选）：1表示新增数据的时候验证，2表示编辑的时候验证，3表示全部情况下都验证（默认）。  

案例：针对部门添加功能，使用自动验证来验证字段的合法性。
说明：如果在自动验证中使用函数(function)来验证字段的合法性，
则第二个参数要求是函数名（函数名要是函数是php内置的函数或者自己定义的函数<可以是函数库中声明的，也可以在当前模型中去定义>）  

注意：因为规则是定义在自定义模型中，所以实例化模型时，必须实例化自定义模型。  
自动验证失败，则create方法返回false，如果验证成功，则返回正常的数组。

输出用户提示信息：  
$model->getError();

```
$model = D('Dept');
if($model->create()){
    $re = $model->add($data);
    if($re){
        $this->success('添加成功',U('lister'),3);
    }else{
        $this->error('添加失败');
    }
}else{
    $this->error($model->getError());
}
```

批量验证：  
需要配置一个成员属性：$patchValidate设置成true
此时批量验证返回的错误信息是一个数组格式
```
array (size=2)
  'name' => string '部门名称不能为空' (length=24)
  'sort' => string '排序必须是数字！' (length=24)
```

## 3、字段映射
映射就是表示一个对应关系。
应用场景：在目前表单中的name值和数据表中的字段名都是一样的，有一些人可能通过当前功能和表单的name值
猜测出数据表的名字和表结构，后期就可能会找到系统的漏洞对系统的进行攻击，系统的安全性存在威胁。  
因此我们可以使用一个障眼法，将name值来随机制定，name值就和表中的字段不一致，那样别人就猜不出来了。  

因为如果字段和数据表中的字段不匹配，在操作的时候会被系统过滤，所以需要有一个对照列表，告知系统，不对应的name字段是数据表中的字段。  

字段映射和自动验证一样，没有语法，只有规则定义：
成员属性： $_map  
```
protected %_map = array();   //字段映射定义
```
因为成员属性是父类模型中的，所以不能在父类中直接修改，需要在自定义模型中修改。  
```
//字段映射定义
protected $_map = array(
    //映射规则  表单name值 => 数据表字段名
    'abc' => 'name',
);
```
因为数据对象中使用了字段映射的检查，所以，此处如果需要使用字段映射，
则必须要使用数据对象的创建方法接收数据($model->create())。  
通过修改前端表单中的name值进行测试
```
<input type="text" name="abc" class="form-control">
```
`dump($model->create())`测试结果：  
```
array (size=3)
  'pid' => string '0' (length=1)
  'sort' => string '23' (length=2)
  'remark' => string '                                            ' (length=44)
```
```
array (size=4)
  'pid' => string '0' (length=1)
  'sort' => string '23' (length=2)
  'remark' => string '                                            ' (length=44)
  'name' => string '前端df' (length=8)
```
在使用字段映射后，被映射的字段会被放到数组的最后，按照字段映射的先后顺序进行排列。  

## 4、特殊表的实例化操作















 ```
 day04 -> 06 -> 0:00
 ```
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 